## Overview

In this section, we will be provisioning/configuring the following:
1. Provisioning Cloud Virtual Machine Instance
2. Configuring Cloud Virtual Machine Instance
3. Provisioning an SSL/TLS Certificate
4. Configuring HTTPS on Nginx

Our main goal in this section is to deploy a HTTP Service on a Cloud Virtual Machine (CVM). By the end of this section, you will have the frontend of the lab deployed with HTTPS configured.

## 1. Provisioning a Cloud Virtual Machine Instance

Click on **Products** on the navigation bar and select **Cloud Virtual Machine** under the **Compute** section

![](figures/02-frontend.png)

Click on the **Create** button to create a new Virtual Machine

![](figures/02-frontend-1.png)

Below are some recommended settings for the deployment of this demo:

| Param             | Value                                  |
| ----------------- | -------------------------------------- |
| Billing mode      | Pay-as-you-go                          |
| Region            | Singapore                              |
| Availability Zone | Singapore Zone 1                       |
| Instance          | Standard SA2 (Or cheaper alternatives) |
| Image             | CentOS 7.9 64bit                       |
| Storage           | Balance SSD, 50 GiB, 1 Qty (default)   |
Select your basic configurations as per below:

![](figures/02-frontend-2.png)
![](figures/02-frontend-3.png)

Next, configure network and host related settings for the VM

![](figures/02-frontend-4.png)
![](figures/02-frontend-5.png)
![](figures/02-frontend-6.png)

Lastly, confirm the configurations are as desired and create the VM

![](figures/02-frontend-7.png)
![](figures/02-frontend-8.png)

## 2. Configuring the Cloud Virtual Machine Instance

After provisioning the CVM in the previous step, you should see the CVM Instance. Click on **Log In** to access the VM

![](figures/02-frontend-8.png)

Select the **Private** Instance IP and select **Key** for the Verification Method.

Click on the **Select Key File** button in the **Private Key** Field and select the key we previously created and downloaded and finally Click **Log in**.


![](figures/02-frontend-9.png)
![](figures/02-frontend-10.png)

After clicking on the **Login** button, you will be presented with a web terminal with a prompt on OrcaTerm as shown below:

![](figures/02-frontend-11.png)

### Installing Nginx

Run the following command to install Nginx on CVM:

```bash
# Install Nginx with yum package manager
$ yum -y install nginx
```

![](figures/02-frontend-12.png)

### Building the React Application Locally

The specific steps to building the React Application locally can be found at `frontend/README.md`

The build will produce a `build.tgz` when the build is complete, which will need to be uploaded to the VM in the next step.

### Upload Static Website Build

To upload the Click on the `SFTP` icon on the OrcaTerm and a File manager will appear, allowing you to upload files. For this demo, we'll upload it to the `/root` directory. Click on the **Upload** button and select your files to upload

![](figures/02-frontend-13.png)

Upload the `build.tgz` file generated by the build in the previous step

![](figures/02-frontend-14.png)
![](figures/02-frontend-15.png)

After you've uploaded the file, run the following commands to create the required directory and unzip the file in the specified directory

```bash
# Creates /usr/share/nginx/html
mkdir -p /usr/share/nginx/html

# Uncompress the build.tgz file at /usr/share/nginx/html
tar -zxf build.tgz --strip-components 1 -C /usr/share/nginx/html
```

![](figures/02-frontend-16.png)

> There may be some error regarding an "Unknown extended header", you may safely ignore this

### Configure Nginx to serve the Static Website

Configure your Nginx by running the following command:

```bash
cat > /etc/nginx/conf.d/default.conf <<"EOF"
server {
  listen 80; # Listen on port 80 (adjust if needed)

  # Access log configuration (adjust paths as needed)
  access_log /var/log/nginx/access.log combined;
  error_log /var/log/nginx/error.log;

  root /usr/share/nginx/html; # Adjust if your build output is in a different location

  location / {
    # try_files $uri $uri/ /index.html?$args;
    index index.html index.htm; # Add other fallback options if needed
  }

  location ~* \.(?:css|js|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$ {
    # Serve static files directly without rewriting
    add_header Cache-Control 'max-age=31536000'; # Optional: Cache static assets for a year
    # add_header Content-Type application/json; # Or appropriate content type based on file extension
    access_log off;
  }
}
EOF
```

![](figures/02-frontend-17.png)

### Enable and Start the Nginx service

By default, Nginx comes with a systemd unit, which enables us to enable the autostart of Nginx on boot using `systemctl enable nginx`.

Enabling autostart doesn't start the service if it isn't starter currently, therefore we will also need to manually start Nginx with `systemctl start nginx`

```bash
# Enable Nginx auto start on boot
systemctl enable nginx

# Start Nginx now
systemctl start nginx
```

![](figures/02-frontend-18.png)

### Access the Static Webpage

You've now successfully hosted your webpage on your VM using Nginx. You can access the Webpage at the Public IP Address of your VM.

You can find the Public IP Address of your VM on the CVM Product Page or look at the Bottom Left of your OrcaTerm login.

![](figures/02-frontend-19.png)
![](figures/02-frontend-20.png)

## 3. Provisioning an SSL/TLS Certificate

From the previous example, we can see that our website is currently running on HTTP.

![](figures/02-frontend-21.png)

This means that any traffic between our Browser and the Server are in plaintext and unencrypted.

In order for us encrypt the traffic between the Browser and the Server, we need to configure our Nginx Web Server to serve its webpage over HTTPS, the secure and encrypted version of HTTP.

#### Creating a free SSL/TLS Certificate

In order for us to configure HTTPS, we need a TLS Certificate and in this step, we will be creating a free TLS Certificate on Tencent Cloud.

Navigate to the **Cloud Load Balancer** Page and click on **Certificate Management** on the sidebar. After which, click on the **Create** button to create a new SSL Certificate

![](figures/02-frontend-22.png)

Next, click on **Apply for free certificate** to apply for free certificate 

![](figures/02-frontend-23.png)

You should be presented with these fields which you have to fill in to create your certificate. Fill in the details with your appropriate domain

Below are the conventions we're following:
- Bound Domain: `<code>-frontend-<region>-<zone-no>.<your-domain>.<tld>`
	- e.g. `ea54c6-frontend-ap-singapore-1.tamlab.xyz`
- Certificate Name: Same as Bound Domain

After filling in the details, click on **Submit application**

![](figures/02-frontend-24.png)

Now you will need to verify your domain by adding a **CNAME** record for your domain. This can be on the DNS Records Management Page provided by your DNS Provider.

![](figures/02-frontend-25.png)

For the example above, we're using a domain registered on the Tencent Cloud Platform that uses DNS Pods to manage

Head over to the **Domain** Product page and select **My Domains** on the Sidebar

![](figures/02-frontend-26.png)

If your domain is registered under Tencent Cloud, you will be able to see it in the listing records as show below. Click on the **DNS** Text Button

![](figures/02-frontend-27.png)

You will be redirected to a page that looks like the image below.
Click on the **Add Record Button**.

![](figures/02-frontend-28.png)

A new record line should appear. Select the **Record Type** Drop down and select **CNAME**.
Also fill in the relevant fields as required by the Certificate Verification Page

![](figures/02-frontend-29.png)

Now head back to the SSL/TLS Certificate Page and click on the **Validate domain** button.
It may take some time to populate the records. If it doesn't work now, try again in a few minutes.

![](figures/02-frontend-32.png)

After you have certificate has been provisioned, you will be able to see the details associated with it.

Now we will click on the **Download** text to download a copy of the certificate.

![](figures/02-frontend-33.png)

When prompted on choosing which **Server type**, select the **Download** text in Nginx section.
 
![](figures/02-frontend-34.png)

## 4. Configure HTTPS on Nginx

Unzip the file downloaded in the previous step

![](figures/02-frontend-35.png)

Run the following command to create the `cert` directory first

```bash
mkdir -p /usr/share/nginx/cert
```

Similarly as before, click on the `SFTP` button and upload the certificate files to `/usr/share/nginx/cert` directory using the OrcaTerm SFTP

![](figures/02-frontend-36.png)
![](figures/02-frontend-37.png)

After uploading the files, rename the files by clicking the **Pencil Icon**:
- Rename the `<code>-frontend-...crt` file to `nginx.crt`
- Rename the `<code>-frontend-...key` file to `nginx.key`

![](figures/02-frontend-38.png)
![](figures/02-frontend-39.png)

Now we need to reconfigure Nginx to use these Certificate and Key files that we've just uploaded.

Run the following command to replace the previous `default.conf` file with one that has SSL/TLS Configured:

```bash
cat > /etc/nginx/conf.d/default.conf <<"EOF"
server {
  listen 80; # Listen on port 80 (adjust if needed)

  # Access log configuration (adjust paths as needed)
  access_log /var/log/nginx/access.log combined;
  error_log /var/log/nginx/error.log;

  root /usr/share/nginx/html; # Adjust if your build output is in a different location
  

  location / {
    try_files $uri $uri/ /index.html?$args;
    index index.html index.htm; # Add other fallback options if needed
  }

  location ~* \.(?:css|js|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$ {
    # Serve static files directly without rewriting
    add_header Cache-Control 'max-age=31536000'; # Optional: Cache static assets for a year
    add_header Content-Type application/json; # Or appropriate content type based on file extension
    access_log off;
  }
}
server {
  listen 443 ssl; 
  server_name fe.soonann.dev; 
  ssl_certificate /usr/share/nginx/cert/nginx.crt; 
  ssl_certificate_key /usr/share/nginx/cert/nginx.key; 
  ssl_session_timeout 5m;
  ssl_protocols TLSv1.2 TLSv1.3; 
  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; 
  ssl_prefer_server_ciphers on;

  # Access log configuration (adjust paths as needed)
  access_log /var/log/nginx/access.log combined;
  error_log /var/log/nginx/error.log;

  root /usr/share/nginx/html; # Adjust if your build output is in a different location
  
    location / {
        proxy_pass http://127.0.0.1:80;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }
	
	location ~* \.(?:css|js|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$ {
		# Serve static files directly without rewriting
		add_header Cache-Control 'max-age=31536000'; # Optional: Cache static assets for a year
		# add_header Content-Type application/json; # Or appropriate content type based on file extension
		access_log off;
	}
}
EOF
systemctl restart nginx
```

![](figures/02-frontend-40.png)

Now we've successfully configured the Nginx Web Server to use HTTPS with the SSL/TLS Certificate we provisioned.

### Testing HTTPS

We can test the HTTPS by accessing the website by the IP Address as we have done previously at `https://<cvm-ip>`

![](figures/02-frontend-41.png)

We will see a warning that warns us our connection is not private. Click the Advanced button and select `Proceed to <cvm-ip> (unsafe)`

![](figures/02-frontend-42.png)

Click on the **Not Secure** button and you will see that there is a certificate tied to the website

![](figures/02-frontend-43.png)

When we check the certificate, we will see that the certificate is issued to the domain we requested it for before. But HTTPS is still not configured properly despite us having a certificate.

![](figures/02-frontend-44.png)

This is because the Address which we access the Nginx Web Server on matters when using HTTPS as SSL/TLS are issued to certain domains.

In order for us to access the Website through our domain, we need to add an A Record on our DNS Provider's Domain Record Management Page


### Configuring DNS Record

Head to your DNS Provider's Management page and create an A Record.
The DNS Provider for this project is DNS Pod, so we will create it on the DNS Pod Platform.
- Host: `<code>-frontend`
- Record Value: `<cvm-ip>`

![](figures/02-frontend-45.png)

DNS Records will take some time to propagate and take effect. After we've added the A Record, we will have to wait for some time. We can check if it has successfully propagated using the `dig` command

```bash
# <code>-frontend-<region>.<your-domain>.<tld>
dig A ea54c6-frontend-ap-singapore.tamlab.xyz
```

Look at the **ANSWER SECTION**, if the value at the end is the `<cvm-ip>` we entered, then the records have propagated. Otherwise, run the command every few minutes to check its status again.

![](figures/02-frontend-46.png)

Eventually, when the records are propagated properly, we can visit the website with HTTPS at `https://<code>-frontend-<region>.<your-domain>.<tld>`

![](figures/02-frontend-47.png)
